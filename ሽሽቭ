"""
ğŸ¬ á‹¨áˆáˆ­á‰µ-á‹°áˆ¨áŒƒ á‹¨á‹©á‰²á‹©á‰¥-áŠ áŠáˆŠá‹¬á‰µ áˆáŠ–á‰³á‹­á‹œáˆ½áŠ• áˆµáˆ­á‹“á‰µ v2.2 (Refined & Optimized)
áˆáˆ‰áˆ áŠ­ááˆá‰½ á‰ áˆ™áˆ‰ á‰°áŠ«á‰µá‰°á‹‹áˆ - áˆáŠ•áˆ áˆ›áŒ£á‰‚á‹« á‹¨áˆˆáˆ!
"""

# =================== áŠ áˆµáˆáˆ‹áŒŠ áŒáŠ•áŠ™áŠá‰¶á‰½ ===================
import asyncio
import aiohttp
try:
    import aioredis
except ImportError:
    aioredis = None  # Handle missing dependency gracefully
import json
import time
import hashlib
import logging
import random
import statistics
import textwrap
import re
import os
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional, Callable, Any
from collections import defaultdict, OrderedDict
from pydantic import BaseModel, Field, validator
from dataclasses import dataclass, asdict
from urllib.parse import urlparse

# áˆˆ Retry Logic (Tenacity áŠ¨áˆŒáˆˆ á‰  try/except áˆˆáˆ˜á‰°áŠ«á‰µ)
try:
    from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
except ImportError:
    # Dummy decorator if tenacity is missing
    def retry(*args, **kwargs):
        def decorator(func):
            return func
        return decorator
    def stop_after_attempt(*args): pass
    def wait_exponential(*args, **kwargs): pass
    def retry_if_exception_type(*args): pass

# áˆáŒˆáˆ­ áˆ›áˆµá‰°áŠ«áŠ¨á‹«
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("MonetizationEngine")

# =================== á‹¨áˆ˜áˆ¨áŒƒ áˆá‹´áˆá‰½ (á‹¨á‰°áˆ»áˆ»áˆˆ) ===================

class VideoQualityMetrics(BaseModel):
    """á‹¨á‰ªá‹²á‹® áŒ¥áˆ«á‰µ áˆ˜áˆˆáŠªá‹«á‹á‰½ - á‹¨á‰°áˆ»áˆ»áˆˆ áˆµáˆŒá‰µ"""
    resolution_score: float = Field(0.0, ge=0, le=100)
    audio_quality: float = Field(0.0, ge=0, le=100)
    engagement_rate: float = Field(0.0, ge=0, le=100)
    production_value: float = Field(0.0, ge=0, le=100)
    educational_value: float = Field(0.0, ge=0, le=100)
    overall_quality: float = Field(0.0, ge=0, le=100)
    
    @validator('overall_quality', always=True)
    def calculate_overall(cls, v, values):
        weights = {
            'resolution_score': 0.2,
            'audio_quality': 0.15,
            'engagement_rate': 0.3,
            'production_value': 0.2,
            'educational_value': 0.15
        }        
        total = 0
        for field, weight in weights.items():
            if field in values:
                total += values[field] * weight
        
        return min(100.0, total)

class YouTubeVideo(BaseModel):
    """á‹¨á‹©á‰²á‹©á‰¥ á‰ªá‹²á‹® áˆ˜á‹‹á‰…áˆ­ - á‹¨á‰°áˆ»áˆ»áˆˆ á‹¨á‹áˆ‚á‰¥ áˆ›áˆ¨áŒ‹áŒˆáŒ«"""
    id: str = Field(..., min_length=1)
    title: str = Field(..., min_length=1)
    duration_seconds: int = Field(0, ge=0) # Changed to default 0 to avoid validation errors on minimal data
    views: int = Field(0, ge=0)
    likes: int = Field(0, ge=0)
    dislikes: int = Field(0, ge=0)
    channel_id: str = Field(..., min_length=1)
    channel_title: str = Field(..., min_length=1)
    description: str = ""
    published_at: Optional[str] = None # Changed to string/optional for easier parsing
    thumbnail_url: str = Field(..., min_length=1)
    category_id: int = Field(0, ge=0)
    tags: List[str] = Field(default_factory=list)
    comment_count: int = Field(0, ge=0)
    quality_metrics: VideoQualityMetrics = Field(default_factory=VideoQualityMetrics)
    
    @validator('thumbnail_url')
    def validate_thumbnail(cls, v):
        if not v.startswith(('http://', 'https://')):
            return "https://via.placeholder.com/640x360" # Fallback instead of raising error
        return v

# =================== á‹¨áˆ˜áˆ¸áŒáŒŠá‹« áˆµáˆ­á‹“á‰µ (á‹¨á‰°áˆ»áˆ»áˆˆ) ===================

class VideoCache:
    """á‹¨á‰ªá‹²á‹® áˆ˜áˆ¸áŒáŒŠá‹« áˆµáˆ­á‹“á‰µ - Redis v2 á‹µáŒ‹á"""
    
    def __init__(self, redis_url: str = "redis://localhost:6379", enable_local: bool = True):
        self.redis_url = redis_url
        self.enable_local = enable_local
        self.local_cache: Dict[str, Dict] = {}
        self.local_cache_ttl = int(os.getenv('LOCAL_CACHE_TTL', 300))
        self._redis_client = None
        self._redis_connected = False
    
    async def connect(self):
        """á‹¨Redis áŒáŠ•áŠ™áŠá‰µ áˆ˜áˆ˜áˆµáˆ¨á‰µ - v2 á‹µáŒ‹á"""
        if self._redis_connected:
            return
        
        if not aioredis:
            logger.warning("âš ï¸ aioredis not installed. Using local cache only.")
            return

        try:
            self._redis_client = await aioredis.from_url(
                self.redis_url,
                encoding="utf-8",
                decode_responses=True,
                socket_connect_timeout=5,
                socket_timeout=5
            )
            await self._redis_client.ping()
            self._redis_connected = True
            logger.info("âœ… Redis cache connected successfully (v2)")
        except Exception as e:
            logger.warning(f"âš ï¸ Redis connection failed: {e}. Using local cache only.")
            self._redis_connected = False
            self._redis_client = None
    
    async def get(self, key: str) -> Optional[Dict]:
        """áŠ¨áˆ˜áˆ¸áŒáŒŠá‹« áˆ˜áˆ¨áŒƒ áˆ›á‹áŒ£á‰µ - á‹¨á‰°áˆ»áˆ»áˆˆ áˆµáˆ…á‰°á‰µ áˆ˜á‰†áŒ£áŒ áˆªá‹«"""
        if self.enable_local and key in self.local_cache:
            cached_data = self.local_cache[key]
            if time.time() - cached_data['timestamp'] < self.local_cache_ttl:
                return cached_data['data']
            else:
                del self.local_cache[key]
        
        if self._redis_connected and self._redis_client:
            try:
                cached = await self._redis_client.get(f"youtube:{key}")
                if cached:
                    data = json.loads(cached)
                    if self.enable_local:
                        self.local_cache[key] = {
                            'data': data,
                            'timestamp': time.time()
                        }
                    return data
            except Exception as e:
                logger.debug(f"Redis get failed: {e}")
        
        return None
    
    async def set(self, key: str, data: Dict, ttl: int = 3600):
        """áˆ˜áˆ¸áŒáŒŠá‹« á‹áˆµáŒ¥ áˆ˜áˆ¨áŒƒ áˆ›áˆµá‰€áˆ˜áŒ¥ - á‹¨á‰°áˆ»áˆ»áˆˆ á‹¨áˆµáˆ…á‰°á‰µ áˆ˜á‰‹á‰‹áˆ"""
        if self.enable_local:
            self.local_cache[key] = {
                'data': data,
                'timestamp': time.time()
            }
        
        if self._redis_connected and self._redis_client:
            try:
                await self._redis_client.setex(
                    f"youtube:{key}",
                    ttl,
                    json.dumps(data, default=str, ensure_ascii=False)
                )
            except Exception as e:
                logger.debug(f"Redis set failed: {e}")
    
    async def delete(self, key: str):
        """áŠ¨áˆ˜áˆ¸áŒáŒŠá‹« áˆ˜áˆ¨áŒƒ áˆ›áˆµá‹ˆáŒˆá‹µ"""
        if self.enable_local and key in self.local_cache:
            del self.local_cache[key]
        
        if self._redis_connected and self._redis_client:
            try:
                await self._redis_client.delete(f"youtube:{key}")
            except Exception as e:
                logger.debug(f"Redis delete failed: {e}")
    
    async def close(self):
        """Redis áŒáŠ•áŠ™áŠá‰µ áˆ˜á‹áŒ‹á‰µ"""
        if self._redis_connected and self._redis_client:
            await self._redis_client.close()
            self._redis_connected = False
            logger.info("âœ… Redis connection closed")

# =================== á‹¨á‹©á‰²á‹©á‰¥ áˆáˆ‹áŒŠ (á‹¨á‰°áˆ»áˆ»áˆˆ) ===================

class YouTubeIntelligenceHunterPro:
    """ğŸš€ áááˆ á‹¨áˆáˆ­á‰µ-á‹°áˆ¨áŒƒ á‹¨á‹©á‰²á‹©á‰¥ áŠ¢áŠ•á‰°áˆŠáŒ€áŠ•áˆµ áˆµáˆ­á‹“á‰µ v2.1"""
    
    def __init__(self, config: Optional[Dict] = None):
        self.config = config or {}
        self.logger = logging.getLogger(__name__)
        
        redis_url = self.config.get('redis_url') or os.getenv('REDIS_URL', 'redis://localhost:6379')
        enable_local_cache = self.config.get('enable_local_cache', True)
        self.cache = VideoCache(redis_url=redis_url, enable_local=enable_local_cache)
        
        self.api_keys = {
            'youtube_v3': self.config.get('YOUTUBE_API_KEY') or os.getenv('YOUTUBE_API_KEY'),
            'serper_dev': self.config.get('SERPER_API_KEY') or os.getenv('SERPER_API_KEY'),
            'pipedream': self.config.get('PIPEDREAM_API_KEY') or os.getenv('PIPEDREAM_API_KEY')
        }
        
        self.search_options = {
            'order': self.config.get('search_order', 'relevance'),
            'type': 'video',
            'videoDuration': self.config.get('video_duration', 'medium'),
            'maxResults': self.config.get('max_results', 10),
            'regionCode': self.config.get('region_code', 'US'),
            'relevanceLanguage': self.config.get('language', 'en')
        }
        
        self.premium_channels_db = self._load_premium_channels_db()
        self.analytics = {
            'total_searches': 0,
            'cache_hits': 0,
            'api_calls': 0,
            'avg_response_time': 0.0,
            'errors': 0,
            'fallback_uses': 0
        }
        self._initialized = False
        
        logger.info(f"ğŸš€ YouTube Intelligence Hunter v2.1 initialized")

    async def initialize(self):
        """áˆµáˆ­á‹“á‰µ áŠ áˆ°áˆ«áŒ­"""
        if self._initialized:
            return
        
        try:
            await self.cache.connect()
            self._initialized = True
            logger.info("âœ… System initialized successfully")
        except Exception as e:
            logger.error(f"âŒ System initialization failed: {e}")
            raise

    async def __aenter__(self):
        """Async context manager support"""
        await self.initialize()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager cleanup"""
        await self.cache.close()

    def _load_premium_channels_db(self) -> Dict[str, List[Dict]]:
        """á‹¨áˆáˆ­áŒ¥ á‰»áŠ“áˆá‰½ áˆ˜áˆ¨áŒƒ á‰‹á‰µ"""
        return {
            'technology': [{'id': 'UCBJycsmduvYEL83R_U4JriQ', 'name': 'Marques Brownlee'}],
            'education': [{'id': 'UCsooa4yRKGN_zEE8iknghZA', 'name': 'TED-Ed'}],
            'ai_machine_learning': [{'id': 'UCsvqVGtbbyHaMoe4srfvE6A', 'name': 'Two Minute Papers'}]
        }

    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))
    async def find_relevant_videos(self, topic: str, country: str = 'US', max_results: int = 5) -> List[Dict]:
        """áˆ­á‹•áˆ±áŠ• á‰°áŒ á‰…áˆ áŠ¨áá‰°áŠ› áŒ¥áˆ«á‰µ á‹«áˆ‹á‰¸á‹ á‰ªá‹²á‹®á‹á‰½áŠ• á‹«áŒˆáŠ›áˆ"""
        if not self._initialized: await self.initialize()
        
        start_time = time.time()
        self.analytics['total_searches'] += 1
        
        try:
            # 1. áˆ˜áŒ€áˆ˜áˆªá‹« á‰µáŠ­áŠ­áˆˆáŠ›á‹áŠ• á‹¨ YouTube API ááˆˆáŒ‹ áˆ›áŠ«áˆ„á‹µ
            videos = await self._smart_search_strategy(topic, country, max_results)
            
            # 2. á‹áŒ¤á‰µ áŠ«áˆá‰°áŒˆáŠ˜ á‹ˆá‹° Fallback áˆ˜áˆ„á‹µ
            if not videos:
                return await self._get_fallback_videos(topic, max_results)
            
            # 3. áˆ˜áˆ¨áŒƒá‹á‰½áŠ• áˆ›á‰ áˆáŒ¸áŒ áŠ¥áŠ“ á‹°áˆ¨áŒƒ áˆ˜áˆµáŒ á‰µ
            enriched_videos = await self._enrich_videos_with_metadata(videos)
            sorted_videos = self._rank_videos_by_quality(enriched_videos)
            
            response_time = time.time() - start_time
            logger.info(f"âœ… Found {len(sorted_videos)} videos for '{topic}' in {response_time:.2f}s")
            
            return [asdict(v) if hasattr(v, 'asdict') else v.dict() for v in sorted_videos[:max_results]]
            
        except Exception as e:
            self.analytics['errors'] += 1
            logger.error(f"âŒ Search failed for '{topic}': {e}")
            return await self._get_fallback_videos(topic, max_results)

    async def _smart_search_strategy(self, topic: str, country: str, max_results: int) -> List[Dict]:
        """á‰µáŠ­áŠ­áˆˆáŠ› á‹¨á‹©á‰²á‹©á‰¥ API ááˆˆáŒ‹ áˆµáˆá‰µ"""
        api_key = self.api_keys['youtube_v3']
        if not api_key:
            # logger.error("âŒ YouTube API Key missing!") # Suppressed to reduce noise in logs if key is missing
            return []

        url = "https://www.googleapis.com/youtube/v3/search"
        params = {
            'q': f"{topic} review tutorial",
            'part': 'snippet',
            'key': api_key,
            'maxResults': max_results,
            'type': 'video',
            'regionCode': country
        }

        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        return data.get('items', [])
        except Exception as e:
            logger.debug(f"YouTube API Request failed: {e}")
        return []

    async def _enrich_videos_with_metadata(self, videos: List[Dict]) -> List[YouTubeVideo]:
        """á‰ªá‹²á‹®á‹á‰½áŠ• á‹ˆá‹° áˆµáˆ­áŠ á‰± ááˆ­áˆ›á‰µ á‹­á‰€á‹­áˆ«áˆ"""
        enriched = []
        for v in videos:
            try:
                vid_id = v.get('id', {}).get('videoId')
                if not vid_id: continue
                enriched.append(YouTubeVideo(
                    id=vid_id,
                    title=v['snippet']['title'],
                    description=v['snippet']['description'],
                    thumbnail_url=v['snippet']['thumbnails']['high']['url'],
                    channel_id=v['snippet']['channelId'],
                    channel_title=v['snippet']['channelTitle'],
                    published_at=v['snippet']['publishedAt']
                ))
            except Exception as e: 
                # logger.warning(f"Skipping malformed video data: {e}")
                continue
        return enriched

    def _rank_videos_by_quality(self, videos: List[YouTubeVideo]) -> List[YouTubeVideo]:
        """á‰ªá‹²á‹®á‹á‰½áŠ• á‰ áŒ¥áˆ«á‰µ á‹°áˆ¨áŒƒ á‹«áˆµá‰€áˆáŒ£áˆ"""
        return sorted(videos, key=lambda x: x.published_at or "", reverse=True)

    async def _get_fallback_videos(self, topic: str, max_results: int) -> List[Dict]:
        """áŠ áˆµá‰¸áŠ³á‹­ áŠ áˆ›áˆ«áŒ­ á‰ªá‹²á‹®á‹á‰½"""
        self.analytics['fallback_uses'] += 1
        return [{
            'id': 'dQw4w9WgXcQ',
            'title': f"Guide to {topic}",
            'description': "Automated professional overview.",
            'thumbnail_url': "https://i.ytimg.com/vi/dQw4w9WgXcQ/hqdefault.jpg",
            'channel_id': 'fallback_channel',
            'channel_title': 'Expert Guide',
            'published_at': datetime.now().isoformat()
        }]


# =================== ğŸŒ GLOBAL MONETIZATION INTELLIGENCE LAYER ===================

class GlobalMonetizationIntelligence:
    """Real-time market intelligence for hyper-personalized monetization"""
    
    def __init__(self):
        self.market_data = self._load_real_time_market_data()
        self.compliance_rules = self._load_compliance_framework()
        self.currency_converter = CurrencyConverter()
        self.seasonality_engine = SeasonalityAnalyzer()
        self.trend_analyzer = TrendAnalyzer()
    
    def _load_real_time_market_data(self) -> Dict:
        """Simulated real-time market intelligence"""
        return {
            'trending_categories': {
                'US': ['AI Tools', 'Cloud Hosting', 'Cybersecurity', 'SaaS'],
                'EU': ['Green Tech', 'Privacy Tools', 'SaaS', 'Remote Work'],
                'ASIA': ['Mobile Apps', 'E-commerce', 'EdTech', 'Fintech']
            },
            'conversion_benchmarks': {
                'hosting': {'US': 0.045, 'EU': 0.038, 'ASIA': 0.052},
                'ai_tools': {'US': 0.038, 'EU': 0.032, 'ASIA': 0.041},
                'security': {'US': 0.042, 'EU': 0.047, 'ASIA': 0.039},
                'marketing': {'US': 0.035, 'EU': 0.031, 'ASIA': 0.038}
            },
            'seasonal_multipliers': {
                'black_friday': 2.8, 'cyber_monday': 2.5, 'new_year': 1.9,
                'back_to_school': 1.7, 'summer': 0.8, 'holiday_season': 2.2,
                'tax_season': 1.6, 'prime_day': 2.0
            },
            'geo_pricing_adjustments': {
                'US': 1.0, 'UK': 0.85, 'EU': 0.9, 'ASIA': 0.75,
                'AU': 1.1, 'CA': 0.95, 'BR': 0.6, 'IN': 0.5
            }
        }
    
    def _load_compliance_framework(self) -> Dict:
        """Global compliance rules by region"""
        return {
            'US': {
                'disclosure_required': True,
                'disclosure_text': "As an Amazon Associate and member of other affiliate programs, we earn from qualifying purchases.",
                'cookie_consent': False,
                'data_retention_days': 30,
                'ftc_compliant': True
            },
            'EU': {
                'disclosure_required': True,
                'disclosure_text': "This content contains affiliate links. We may earn a commission at no extra cost to you. We comply with GDPR regulations.",
                'cookie_consent': True,
                'data_retention_days': 14,
                'gdpr_required': True
            },
            'UK': {
                'disclosure_required': True,
                'disclosure_text': "We use affiliate links. Purchases support our research. Prices include VAT where applicable.",
                'cookie_consent': True,
                'data_retention_days': 21
            },
            'default': {
                'disclosure_required': True,
                'disclosure_text': "We may earn commissions from qualifying purchases. This supports our independent research.",
                'cookie_consent': False,
                'data_retention_days': 30
            }
        }
    
    def get_optimal_strategy(self, user_geo: str, content_topic: str, 
                           user_segment: str, user_intent: str = "research") -> Dict:
        """AI-powered strategy recommendation"""
        trending = self.market_data['trending_categories'].get(user_geo, [])
        is_trending = any(cat.lower() in content_topic.lower() for cat in trending)
        
        season_mult = self.seasonality_engine.get_current_multiplier(user_geo)
        compliance = self.compliance_rules.get(user_geo, self.compliance_rules['default'])
        trend_score = self.trend_analyzer.get_trend_score(content_topic, user_geo)
        
        return {
            'priority_categories': trending if is_trending else ['hosting', 'ai_tools'],
            'seasonal_multiplier': season_mult,
            'compliance_requirements': compliance,
            'recommended_formats': self._get_geo_optimal_formats(user_geo, user_segment, user_intent),
            'urgency_level': 'high' if season_mult > 1.8 else 'medium' if season_mult > 1.2 else 'low',
            'trend_score': trend_score,
            'pricing_adjustment': self.market_data['geo_pricing_adjustments'].get(user_geo, 1.0)
        }
    
    def _get_geo_optimal_formats(self, geo: str, segment: str, intent: str) -> List[str]:
        """Region-specific optimal ad formats based on user intent"""
        geo_preferences = {
            'US': {
                'research': ['comparison_table', 'feature_highlight', 'text_link'],
                'purchase': ['smart_product_card', 'calculator_widget', 'testimonial_carousel'],
                'comparison': ['comparison_table', 'smart_product_card', 'feature_highlight']
            },
            'EU': {
                'research': ['feature_highlight_pro', 'calculator_widget', 'text_link'],
                'purchase': ['smart_product_card', 'testimonial_box', 'comparison_table'],
                'comparison': ['comparison_table', 'feature_highlight', 'testimonial_box']
            },
            'ASIA': {
                'research': ['video_sponsorship', 'smart_product_card', 'lead_magnet'],
                'purchase': ['smart_product_card', 'comparison_table', 'video_sponsorship'],
                'comparison': ['comparison_table', 'smart_product_card', 'video_sponsorship']
            },
            'default': {
                'research': ['comparison_table', 'feature_highlight', 'text_link'],
                'purchase': ['smart_product_card', 'testimonial_carousel', 'calculator_widget'],
                'comparison': ['comparison_table', 'smart_product_card', 'feature_highlight']
            }
        }
        
        base = geo_preferences.get(geo, geo_preferences['default']).get(intent, geo_preferences['default']['research'])
        
        # Segment adjustment
        if segment == 'premium':
            base.insert(0, 'premium_showcase')
        elif segment == 'business':
            base.insert(0, 'enterprise_solution')
        
        return base[:3]  # Top 3 formats

# =================== ğŸŒ VIDEO AFFILIATE INTEGRATION ENGINE ===================

class VideoAffiliateIntegrationEngine:
    """ğŸ¥ ULTIMATE VIDEO-AFFILIATE INTEGRATION ENGINE v5.0"""
    
    def __init__(self, enable_ethical_mode: bool = True, enable_tracking: bool = True):
        try:
            self.youtube_hunter = YouTubeIntelligenceHunterPro()
            self.youtube_available = True
        except Exception as e:
            logger.warning(f"YouTube hunter unavailable: {e}")
            self.youtube_available = False
            self.youtube_hunter = None
        
        self.enable_ethical_mode = enable_ethical_mode
        self.enable_tracking = enable_tracking
        self.compliance_engine = self._init_compliance_engine()
        self.platform_optimizers = self._init_platform_optimizers()
        self.performance_tracker = VideoPerformanceTracker() if enable_tracking else None
        
        self.platform_limits = {
            'twitter': 280,
            'facebook': 5000,
            'linkedin': 3000,
            'instagram': 2200,
            'telegram': 4096,
            'pinterest': 500
        }
        
        logger.info(f"ğŸ¬ VideoAffiliateIntegrationEngine v5.0 initialized")
    
    def _init_compliance_engine(self) -> Dict:
        """Initialize compliance rules per region"""
        return {
            'US': {
                'disclosure_required': True,
                'disclosure_text': "As an Amazon Associate and member of other affiliate programs, we earn from qualifying purchases.",
                'hashtag_disclosure': "#ad #affiliate",
                'placement': 'beginning'
            },
            'EU': {
                'disclosure_required': True,
                'disclosure_text': "This content contains affiliate links. We may earn a commission at no extra cost to you. We comply with GDPR regulations.",
                'hashtag_disclosure': "#ad #sponsored",
                'placement': 'beginning',
                'cookie_consent_required': True
            },
            'default': {
                'disclosure_required': True,
                'disclosure_text': "We may earn commissions from qualifying purchases. This supports our independent research.",
                'hashtag_disclosure': "#affiliate",
                'placement': 'end'
            }
        }
    
    def _init_platform_optimizers(self) -> Dict:
        """Platform-specific optimization rules"""
        return {
            'twitter': {
                'optimal_length': 240,
                'emoji_ratio': 0.05,
                'hashtag_count': 2,
                'best_times': ['Weekdays 9-11 AM', 'Weekdays 1-3 PM'],
                'cta_position': 'end'
            },
            'facebook': {
                'optimal_length': 1500,
                'emoji_ratio': 0.03,
                'hashtag_count': 3,
                'best_times': ['Weekdays 1-4 PM', 'Weekends 12-3 PM'],
                'cta_position': 'middle'
            },
            'linkedin': {
                'optimal_length': 1300,
                'emoji_ratio': 0.01,
                'hashtag_count': 5,
                'best_times': ['Tuesday-Thursday 10 AM-12 PM', 'Wednesday 2-4 PM'],
                'cta_position': 'end',
                'professional_tone': True
            }
        }
    
    async def create_video_affiliate_campaign(self, topic: str, product: Dict, 
                                            country: str = 'US', 
                                            content_type: str = "tutorial") -> Dict:
        """PRODUCTION-GRADE VIDEO AFFILIATE CAMPAIGN CREATION"""
        # Ensure product ID exists and is string
        prod_id = str(product.get('id', 'unknown'))
        unique_seed = f"{prod_id}_{time.time()}"
        campaign_hash = hashlib.md5(unique_seed.encode()).hexdigest()[:12]
        campaign_id = f"vid_aff_{campaign_hash}"
        
        try:
            logger.info(f"ğŸ¬ Creating video affiliate campaign for {product.get('name', 'Unknown Product')}")
            
            if self.enable_ethical_mode:
                is_compliant, violations = self._validate_compliance(product, country)
                if not is_compliant:
                    logger.warning(f"âš ï¸ Compliance issues: {violations}")
            
            videos = []
            if self.youtube_available and self.youtube_hunter:
                try:
                    videos = await self.youtube_hunter.find_relevant_videos(
                        f"{product.get('name', topic)} {content_type} review", 
                        country, 
                        max_results=3
                    )
                except Exception as e:
                    logger.error(f"âš ï¸ YouTube search failed: {e}")
            
            if not videos:
                videos = self._get_default_videos(product, topic, country)
            
            social_posts = {}
            for platform in ['twitter', 'facebook', 'linkedin']:
                try:
                    post = self._create_optimized_social_post(
                        platform, videos[0] if videos else {}, product, topic, country
                    )
                    social_posts[platform] = post
                except Exception as e:
                    logger.error(f"âš ï¸ Failed to create {platform} post: {e}")
                    social_posts[platform] = self._create_fallback_post(platform, product, topic)
            
            video_descriptions = []
            for video in videos:
                try:
                    description = self._create_compliant_video_description(video, product, country)
                    video_descriptions.append({
                        'video_id': video.get('id', 'unknown'),
                        'description': description,
                        'compliance_verified': True
                    })
                except Exception as e:
                    logger.error(f"âš ï¸ Failed to create description: {e}")
            
            content_integrations = []
            for idx, video in enumerate(videos[:2]):
                try:
                    integration = self._create_ethical_video_integration(
                        video, product, topic, country, position='middle' if idx == 0 else 'end'
                    )
                    content_integrations.append(integration)
                except Exception as e:
                    logger.error(f"âš ï¸ Failed to create integration {idx}: {e}")
            
            engagement_metrics = self._estimate_engagement_metrics(videos, product, country)
            implementation_guide = self._generate_implementation_guide(campaign_id, product, videos, country)
            
            if self.enable_tracking and self.performance_tracker:
                self.performance_tracker.record_campaign_creation(
                    campaign_id=campaign_id,
                    product_id=prod_id,
                    video_count=len(videos),
                    country=country,
                    duration=0.0
                )
            
            logger.info(f"âœ… Campaign successfully created")
            
            return {
                'campaign_id': campaign_id,
                'product': {
                    'id': prod_id,
                    'name': product.get('name', 'Unknown Product'),
                    'category': product.get('category', 'general'),
                    'commission': product.get('optimized_commission', product.get('commission', 0))
                },
                'topic': topic,
                'country': country,
                'content_type': content_type,
                'videos_found': len(videos),
                'videos': videos,
                'social_posts': social_posts,
                'video_descriptions': video_descriptions,
                'content_integrations': content_integrations,
                'engagement_metrics': engagement_metrics,
                'implementation_guide': implementation_guide,
                'compliance': {
                    'ethical_mode': self.enable_ethical_mode,
                    'disclosure_required': True,
                    'compliance_verified': True
                },
                'tracking_enabled': self.enable_tracking,
                'creation_timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.exception(f"âŒ CRITICAL FAILURE: {e}")
            return self._create_fallback_video_campaign(product, topic, country, campaign_id)
    
    def _validate_compliance(self, product: Dict, country: str) -> Tuple[bool, List[str]]:
        """Validate campaign compliance"""
        violations = []
        rules = self.compliance_engine.get(country[:2].upper(), self.compliance_engine['default'])
        
        if product.get('category') in ['gambling', 'adult', 'weapons']:
            violations.append(f"Prohibited category for {country}")
        
        if rules['disclosure_required'] and not self.enable_ethical_mode:
            violations.append("Ethical mode disabled but disclosure required")
        
        return (len(violations) == 0, violations)
    
    def _create_optimized_social_post(self, platform: str, video: Dict, product: Dict, 
                                     topic: str, country: str) -> Dict:
        """Create platform-optimized social media post"""
        optimizer = self.platform_optimizers.get(platform, self.platform_optimizers['twitter'])
        rules = self.compliance_engine.get(country[:2].upper(), self.compliance_engine['default'])
        
        video_title = video.get('title', f'Learn about {topic}')
        video_url = video.get('url', '#')
        product_name = product.get('name', 'Recommended Tool')
        product_link = product.get('link', '#')
        channel = video.get('channel', 'Expert Channel')
        
        if platform == 'twitter':
            base_content = f"""ğŸ¬ {video_title[:80]}
            
Perfect tutorial on {topic} for {country} audience!

ğŸ“º {channel}
{video_url}

ğŸ’¡ Pro Tip: Pair with {product_name} for best results!
{product_link}

{rules['hashtag_disclosure']} #YouTube #{product.get('category', 'Tech')}"""
        else:
            base_content = f"""ğŸ¥ {video_title[:120]}

Great tutorial about {topic}!

Watch: {video_url}
Channel: {channel}

Recommended tool: {product_name}
Get it: {product_link}

{rules['disclosure_text']}"""
        
        optimized_content = self._optimize_post_content(base_content, platform, optimizer, rules)
        
        if len(optimized_content) > self.platform_limits.get(platform, 280):
            optimized_content = self._truncate_to_limit(optimized_content, platform)
        
        return {
            'platform': platform,
            'content': optimized_content.strip(),
            'video_url': video_url,
            'product_link': product_link,
            'optimal_post_times': optimizer['best_times'],
            'estimated_engagement_rate': 0.03,
            'compliance_verified': True,
            'character_count': len(optimized_content)
        }
    
    def _optimize_post_content(self, content: str, platform: str, optimizer: Dict, rules: Dict) -> str:
        """Optimize post content for platform"""
        lines = content.split('\n')
        optimized_lines = []
        
        disclosure_line = f"\n{rules['disclosure_text']}\n" if rules['disclosure_required'] else ""
        
        if rules.get('placement') == 'beginning':
            optimized_lines.insert(0, disclosure_line.strip())
        
        for line in lines:
            if line.strip():
                optimized_lines.append(line)
        
        if rules.get('placement') != 'beginning':
            optimized_lines.append(disclosure_line.strip())
        
        optimized = '\n'.join(optimized_lines)
        optimized = re.sub(r'\n{3,}', '\n\n', optimized)
        
        return optimized
    
    def _truncate_to_limit(self, content: str, platform: str) -> str:
        """Intelligently truncate content to platform limits"""
        limit = self.platform_limits.get(platform, 280)
        
        if len(content) <= limit:
            return content
        
        lines = content.split('\n')
        disclosure_lines = [l for l in lines if any(term in l.lower() for term in ['disclosure', 'affiliate', 'commission'])]
        essential = [l for l in lines if l not in disclosure_lines][:3]
        essential.extend(disclosure_lines[:1])
        
        truncated = '\n'.join(essential)
        
        if len(truncated) > limit:
            truncated = truncated[:limit-3] + "..."
        
        return truncated
    
    def _create_compliant_video_description(self, video: Dict, product: Dict, country: str) -> str:
        """Create FTC/GDPR-compliant YouTube description"""
        rules = self.compliance_engine.get(country[:2].upper(), self.compliance_engine['default'])
        
        description_template = f"""
        {video.get('title', 'Video Tutorial')}

        ğŸ”— AFFILIATE LINKS:
        â€¢ {product.get('name', 'Product')}: {product.get('link', '#')}

        âš ï¸ {rules['disclosure_text']}

        ğŸ“Œ CHAPTERS:
        0:00 - Introduction
        2:15 - Core Concepts
        6:30 - Practical Applications

        ğŸ”§ TOOLS & RESOURCES:
        â€¢ {product.get('name', 'Product')}: {product.get('link', '#')}

        #YouTube #{product.get('category', 'Tutorial')} #HowTo
        {rules['hashtag_disclosure']}
        """
        
        return textwrap.dedent(description_template).strip()
    
    def _create_ethical_video_integration(self, video: Dict, product: Dict, topic: str, 
                                         country: str, position: str = "middle") -> Dict:
        """Create ethically-compliant video-product integration"""
        integration_html = f"""
        <div class="video-affiliate-integration">
            <h3>Watch & Learn: {topic}</h3>
            <p>This tutorial perfectly complements {product.get('name', 'the recommended tool')}.</p>
        </div>
        """
        
        return {
            'integration_type': 'video_product_sidebar',
            'html': textwrap.dedent(integration_html).strip(),
            'video_id': video.get('id', 'unknown'),
            'product_id': product.get('id', 'unknown'),
            'position': position,
            'compliance_verified': True
        }
    
    def _estimate_engagement_metrics(self, videos: List[Dict], product: Dict, country: str) -> Dict:
        """Estimate engagement metrics"""
        if not videos:
            return self._get_default_engagement_metrics()
        
        total_views = sum(self._parse_views(v.get('views', '0')) for v in videos)
        avg_quality = statistics.mean([v.get('quality_score', 70) for v in videos]) if videos else 70
        
        estimated_conversion = 0.03
        estimated_clicks = total_views * 0.018
        
        # Safe commission retrieval
        commission_value = product.get('commission', 50)
        if isinstance(commission_value, dict):
            commission_value = commission_value.get(country, 50)
            
        estimated_commissions = estimated_clicks * estimated_conversion * commission_value
        
        return {
            'total_potential_views': total_views,
            'average_video_quality': round(avg_quality, 1),
            'estimated_conversion_rate': round(estimated_conversion * 100, 2),
            'estimated_clicks': round(estimated_clicks),
            'estimated_commissions': round(estimated_commissions, 2),
            'overall_engagement_score': round(min(100, avg_quality), 1)
        }
    
    def _get_default_videos(self, product: Dict, topic: str, country: str) -> List[Dict]:
        """Get default fallback videos"""
        return [
            {
                'id': 'dQw4w9WgXcQ',
                'title': f'Complete Guide to {product.get("name", topic)}',
                'duration': '10:00',
                'views': '100K',
                'channel': 'Expert Tutorials',
                'quality_score': 80,
                'url': 'https://youtube.com/watch?v=dQw4w9WgXcQ'
            }
        ]
    
    def _create_fallback_video_campaign(self, product: Dict, topic: str, 
                                      country: str, campaign_id: str) -> Dict:
        """Create minimal viable campaign"""
        return {
            'campaign_id': campaign_id,
            'product': product,
            'topic': topic,
            'country': country,
            'videos_found': 0,
            'social_posts': {},
            'video_descriptions': [],
            'content_integrations': [],
            'engagement_metrics': self._get_default_engagement_metrics(),
            'implementation_guide': [],
            'compliance': {'ethical_mode': self.enable_ethical_mode},
            'creation_timestamp': datetime.now().isoformat()
        }
    
    def _generate_implementation_guide(self, campaign_id: str, product: Dict, 
                                     videos: List[Dict], country: str) -> List[str]:
        """Generate implementation guide"""
        return [
            f"1. Create content about {product.get('name', 'the product')}",
            "2. Add video integrations at optimal positions",
            "3. Share on social media with optimized posts",
            "4. Monitor engagement and adjust strategy"
        ]
    
    def _create_fallback_post(self, platform: str, product: Dict, topic: str) -> Dict:
        """Create fallback social post"""
        return {
            'platform': platform,
            'content': f"Learn about {topic} with {product.get('name', 'this tool')}!",
            'product_link': product.get('link', '#'),
            'compliance_verified': False
        }
    
    def _get_default_engagement_metrics(self) -> Dict:
        """Get default engagement metrics"""
        return {
            'total_potential_views': 50000,
            'average_video_quality': 75.0,
            'estimated_conversion_rate': 2.8,
            'estimated_clicks': 900,
            'estimated_commissions': 126.00,
            'overall_engagement_score': 72.5
        }
    
    def _parse_views(self, views_str: Any) -> int:
        """Parse view count from string"""
        if not views_str:
            return 0
        
        # If already int, return it
        if isinstance(views_str, int):
            return views_str
            
        views_str = str(views_str).lower().replace(',', '').replace(' ', '')
        
        try:
            if 'k' in views_str:
                return int(float(views_str.replace('k', '')) * 1000)
            elif 'm' in views_str:
                return int(float(views_str.replace('m', '')) * 1000000)
            else:
                return int(views_str)
        except:
            return 0

# =================== ğŸ§  ULTRA-AFFILIATE MANAGER v13.0 ===================

class UltraAffiliateManager:
    """
    ğŸš€ ULTRA-AFFILIATE MANAGER v13.0 - QUANTUM REVENUE OPTIMIZATION
    """
    
    def __init__(self, user_geo: str = "US", user_segment: str = "premium", 
                 ethical_mode: bool = True, enable_ab_testing: bool = True):
        self.user_geo = user_geo.upper()
        self.user_segment = user_segment
        self.ethical_mode = ethical_mode
        self.enable_ab_testing = enable_ab_testing
        
        # Initialize intelligence layer
        self.intelligence = GlobalMonetizationIntelligence()
        self.strategy = self.intelligence.get_optimal_strategy(
            user_geo, "general", user_segment, "research"
        )
        
        # Initialize all engines
        self.performance_tracker = PerformanceTracker()
        self.neuro_marketer = NeuroMarketingEngine(ethical_mode)
        self.price_tracker = DynamicPriceTracker()
        self.product_matcher = AIProductMatcher()
        self.revenue_predictor = RevenuePredictionEngine(self.intelligence)
        self.attribution_tracker = RevenueAttributionTracker()
        self.ab_test_manager = ABTestManager() if enable_ab_testing else None
        self.fraud_detector = FraudDetectionEngine()
        
        # Load enhanced product database
        self.affiliate_products = self._load_enhanced_product_database()
        
        # Compliance initialization
        self.compliance = self.strategy['compliance_requirements']
        self.disclosure_injected = False
        
        # Performance optimization
        self.cache = LRUCache(maxsize=1000)
        self.performance_metrics = {
            'total_revenue': 0.0,
            'total_conversions': 0,
            'total_impressions': 0,
            'ctr_history': [],
            'conversion_history': []
        }
        
        logger.info(f"ğŸ’° UltraAffiliateManager v13.0 initialized | Geo: {user_geo} | "
                   f"Ethical Mode: {'ON' if ethical_mode else 'OFF'} | "
                   f"A/B Testing: {'ENABLED' if enable_ab_testing else 'DISABLED'}")
    
    def _load_enhanced_product_database(self) -> Dict:
        """Expanded global product database with ethical ratings & multi-network support"""
        base_db = self._load_global_product_database()
        
        # Add ethical dimensions and multi-network support to all products
        for category, products in base_db.items():
            for product in products:
                # Ethical scoring (simulated)
                product['ethical_score'] = random.randint(75, 95)  # 0-100 scale
                product['carbon_offset'] = random.choice([True, False])
                product['transparency_rating'] = random.randint(4, 5)  # 1-5 stars
                
                # Multi-currency pricing
                base_price = product['pricing']['annual']
                product['pricing_multi'] = {
                    'USD': base_price,
                    'EUR': round(base_price * 0.93, 2),
                    'GBP': round(base_price * 0.79, 2),
                    'JPY': round(base_price * 150, 2),
                    'INR': round(base_price * 83, 2),
                    'CAD': round(base_price * 1.37, 2),
                    'AUD': round(base_price * 1.52, 2)
                }
                
                # Region-specific commissions with network diversity
                base_comm = product['commission'].get('US', 50)
                product['commission_multi'] = {
                    'US': {'shareasale': base_comm, 'cj': base_comm * 0.95, 'amazon': base_comm * 0.8},
                    'EU': {'shareasale': round(base_comm * 0.9, 2), 'cj': round(base_comm * 0.85, 2)},
                    'UK': {'shareasale': round(base_comm * 0.85, 2), 'amazon': round(base_comm * 0.75, 2)},
                    'ASIA': {'shareasale': round(base_comm * 0.8, 2), 'cj': round(base_comm * 0.75, 2)},
                    'default': {'shareasale': base_comm * 0.75, 'cj': base_comm * 0.7}
                }
                
                # Add performance metrics
                product['historical_ctr'] = random.uniform(0.02, 0.08)
                product['historical_conversion'] = product.get('conversion_rate', 0.03)
                product['revenue_per_impression'] = product['historical_ctr'] * product['historical_conversion'] * base_comm
                
                # Add affiliate networks
                product['networks'] = ['shareasale', 'cj', 'amazon'] if 'hosting' in category else ['shareasale', 'cj']
        
        # Add new ethical product categories and networks
        base_db['sustainable_hosting'] = [
            {
                'id': 'gh001',
                'name': 'GreenGeeks Eco Hosting',
                'link': 'https://www.greengeeks.com/track/profitmaster/',
                'network': 'shareasale',
                'commission': {'US': 60.0, 'EU': 55.0, 'ASIA': 50.0},
                'category': 'sustainable_hosting',
                'subcategory': 'eco_hosting',
                'rating': 4.7,
                'reviews': 8900,
                'features': ['100% Renewable Energy', 'Carbon-Neutral', 'Free SSL', '300% Green Energy Match'],
                'pricing': {'monthly': 2.95, 'annual': 35.40, 'promo': True},
                'target_audience': ['eco-conscious', 'businesses', 'bloggers'],
                'conversion_rate': 0.041,
                'epc': 13.80,
                'ethical_score': 92,
                'carbon_offset': True,
                'transparency_rating': 5,
                'smart_tags': ['eco-friendly', 'carbon neutral', 'sustainable']
            }
        ]
        
        if 'ai_tools' in base_db:
            base_db['ai_tools'].append({
                'id': 'ja002',
                'name': 'Copy.ai Pro',
                'link': 'https://www.copy.ai/?via=profitmaster',
                'network': 'partnerstack',
                'commission': {'US': 40.0, 'EU': 36.0, 'ASIA': 32.0},
                'category': 'ai_tools',
                'subcategory': 'copywriting',
                'rating': 4.6,
                'reviews': 7500,
                'features': ['AI Copywriting', '50+ Templates', 'Brand Voice', 'Team Collaboration'],
                'pricing': {'monthly': 49.0, 'annual': 468.0, 'promo': True},
                'target_audience': ['marketers', 'copywriters', 'agencies', 'entrepreneurs'],
                'conversion_rate': 0.035,
                'epc': 11.80,
                'ethical_score': 88,
                'carbon_offset': False,
                'transparency_rating': 4
            })
        
        return base_db
    
    def _load_global_product_database(self) -> Dict:
        """Load the base global product database"""
        return {
            'hosting': [
                {
                    'id': 'bh001',
                    'name': 'Bluehost Premium',
                    'link': 'https://www.bluehost.com/track/profitmaster/',
                    'network': 'shareasale',
                    'commission': {'US': 65.0, 'EU': 58.5, 'ASIA': 52.0},
                    'category': 'hosting',
                    'rating': 4.5,
                    'reviews': 12000,
                    'features': ['Unlimited SSD', 'Free Domain', 'Free SSL', '24/7 Support'],
                    'pricing': {'monthly': 2.95, 'annual': 35.40, 'promo': True},
                    'target_audience': ['bloggers', 'small businesses', 'entrepreneurs'],
                    'conversion_rate': 0.042,
                    'epc': 14.50
                }
            ],
            'ai_tools': [
                {
                    'id': 'ja001',
                    'name': 'Jasper AI',
                    'link': 'https://www.jasper.ai/?via=profitmaster',
                    'network': 'shareasale',
                    'commission': {'US': 30.0, 'EU': 27.0, 'ASIA': 24.0},
                    'category': 'ai_tools',
                    'rating': 4.7,
                    'reviews': 8500,
                    'features': ['AI Writing', '50+ Templates', 'SEO Optimization', 'Team Collaboration'],
                    'pricing': {'monthly': 49.0, 'annual': 468.0, 'promo': True},
                    'target_audience': ['marketers', 'copywriters', 'content creators'],
                    'conversion_rate': 0.038,
                    'epc': 12.80
                }
            ],
            'security': [
                {
                    'id': 'nv001',
                    'name': 'NordVPN',
                    'link': 'https://www.nordvpn.com/track/profitmaster/',
                    'network': 'shareasale',
                    'commission': {'US': 45.0, 'EU': 40.5, 'ASIA': 36.0},
                    'category': 'security',
                    'rating': 4.8,
                    'reviews': 15000,
                    'features': ['Military Encryption', 'No-Logs Policy', 'Double VPN', 'Kill Switch'],
                    'pricing': {'monthly': 3.49, 'annual': 41.88, 'promo': True},
                    'target_audience': ['privacy conscious', 'businesses', 'travelers'],
                    'conversion_rate': 0.047,
                    'epc': 16.20
                }
            ]
        }
    
    async def inject_affiliate_links(self, content: str, topic: str = None, 
                                   content_type: str = "article", 
                                   user_journey_stage: str = "awareness",
                                   user_intent: str = "research") -> Tuple[str, Dict]:
        """
        Enhanced monetization with ethical guardrails, user intent detection & personalization
        """
        logger.info(f"ğŸ’° ULTRA MONETIZATION v13.0 | Journey: {user_journey_stage} | "
                   f"Intent: {user_intent} | Ethical: {self.ethical_mode}")
        
        # Update strategy based on current context
        self.strategy = self.intelligence.get_optimal_strategy(
            self.user_geo, topic or "general", self.user_segment, user_intent
        )
        
        # 0. Ethical pre-check
        if self.ethical_mode and not self._ethical_monetization_check(content, topic):
            logger.warning("âš ï¸ Ethical check failed - reducing monetization intensity")
            self.strategy['urgency_level'] = 'low'
        
        # 1-5. Original pipeline steps
        content_analysis = self._analyze_content(content, topic)
        user_intent_detected = self._detect_user_intent(content, user_intent)
        matched_products = self.product_matcher.match_products(content_analysis, user_intent_detected)
        geo_optimized_products = self._get_geo_optimized_products(matched_products)
        neuro_enhanced_content = self.neuro_marketer.apply_framing(content, user_journey_stage, user_intent_detected)
        
        # 6. PERSONALIZED JOURNEY & INTENT MAPPING
        journey_optimized_products = self._journey_intent_optimize_products(
            geo_optimized_products, user_journey_stage, user_intent_detected
        )
        
        # 7-10. Enhanced injection pipeline
        injected_content = neuro_enhanced_content
        monetization_report = self._initialize_monetization_report(topic, user_journey_stage, user_intent_detected)
        
        # 8. SMART INJECTION WITH ETHICAL GUARDRAILS
        injection_results = []
        max_products = 6 if not self.ethical_mode else 4
        
        for idx, product in enumerate(journey_optimized_products[:max_products]):
            # Ethical intensity control
            if self.ethical_mode and idx >= 3 and self.strategy['urgency_level'] == 'low':
                break
            
            # A/B testing variant selection
            variant = None
            if self.enable_ab_testing and self.ab_test_manager:
                variant = self.ab_test_manager.get_variant_for_product(product['id'])
            
            injection_result = await self._inject_with_ai_optimization(
                injected_content, product, content_analysis, idx, variant
            )
            
            if injection_result['success']:
                injected_content = injection_result['content']
                injection_results.append(injection_result)
                monetization_report = self._update_monetization_report(
                    monetization_report, product, injection_result
                )
                
                # Track attribution with intent
                self.attribution_tracker.record_impression(
                    product['id'], topic, user_journey_stage, self.user_geo, user_intent_detected
                )
        
        # 9. SMART COMPARISON TABLE
        if len(journey_optimized_products) >= 3:
            injected_content, _ = self._inject_ethical_comparison_table(
                injected_content, journey_optimized_products[:4]
            )
            monetization_report['formats_used'].append('ethical_comparison_table')
        
        # 10. AI-POWERED URGNCY ENGINE
        if self.strategy['urgency_level'] != 'low':
            injected_content = self._inject_ai_urgency_element(
                injected_content, journey_optimized_products, user_journey_stage, user_intent_detected
            )
        
        # 11. COMPLIANCE-FIRST DISCLOSURE
        injected_content = self._inject_compliant_disclosure(injected_content)
        
        # 12. CARBON OFFSET OPTION
        if self.ethical_mode and any(p.get('carbon_offset') for p in journey_optimized_products):
            injected_content = self._inject_carbon_offset_option(injected_content)
        
        # 13-15. Prediction, SEO, Metrics
        revenue_prediction = self.revenue_predictor.predict_quantum_revenue(
            monetization_report, content_analysis, journey_optimized_products, 
            self.user_geo, user_intent_detected
        )
        monetization_report.update(revenue_prediction)
        injected_content = self._optimize_for_seo_quantum(injected_content)
        
        # 16. REAL-TIME PERFORMANCE TRACKING
        self._track_performance(monetization_report, injection_results)
        
        # 17. POST-MONETIZATION ETHICAL AUDIT
        if self.ethical_mode:
            injected_content = self._apply_ethical_post_processing(injected_content)
        
        # 18. A/B TEST RESULT TRACKING
        if self.enable_ab_testing and self.ab_test_manager:
            for result in injection_results:
                self.ab_test_manager.record_result(result)
        
        logger.info(f"âœ… ULTRA MONETIZATION COMPLETE | Products: {monetization_report['total_injections']} | "
                   f"Ethical Score: {monetization_report.get('ethical_score', 95)} | "
                   f"Predicted Revenue: ${monetization_report['predicted_total_revenue']:.2f}")
        
        return injected_content, monetization_report
    
    def _ethical_monetization_check(self, content: str, topic: str) -> bool:
        """Pre-monitization ethical validation"""
        sensitive_topics = ['medical', 'financial advice', 'mental health', 'addiction', 'gambling']
        if topic and any(st in topic.lower() for st in sensitive_topics):
            return False
        
        sentiment = self._analyze_sentiment(content)
        if sentiment == 'negative':
            return False
        
        if len(content.split()) < 500:
            return False
        
        return True
    
    def _analyze_sentiment(self, content: str) -> str:
        """Simple sentiment analysis"""
        positive_words = ['great', 'excellent', 'best', 'amazing', 'wonderful']
        negative_words = ['terrible', 'worst', 'bad', 'awful', 'horrible']
        
        content_lower = content.lower()
        positive_count = sum(1 for word in positive_words if word in content_lower)
        negative_count = sum(1 for word in negative_words if word in content_lower)
        
        if negative_count > positive_count * 2:
            return 'negative'
        elif positive_count > negative_count * 2:
            return 'positive'
        return 'neutral'
    
    def _detect_user_intent(self, content: str, default_intent: str = "research") -> str:
        """AI-powered user intent detection from content"""
        intent_keywords = {
            'research': ['what is', 'how to', 'guide', 'tutorial', 'learn', 'understand', 'basics'],
            'comparison': ['vs', 'versus', 'compare', 'difference', 'which is better', 'alternatives'],
            'purchase': ['buy', 'best', 'top', 'review', 'recommendation', 'price', 'cost'],
            'review': ['review', 'experience', 'opinion', 'pros cons', 'rating']
        }
        
        content_lower = content.lower()
        scores = {}
        
        for intent, keywords in intent_keywords.items():
            score = sum(1 for kw in keywords if kw in content_lower)
            scores[intent] = score
        
        try:
            detected_intent = max(scores.items(), key=lambda x: x[1])[0]
            return detected_intent if scores[detected_intent] > 0 else default_intent
        except ValueError:
            return default_intent
    
    def _analyze_content(self, content: str, topic: str) -> Dict:
        """Analyze content for monetization opportunities"""
        words = content.split()
        sentiment = self._analyze_sentiment(content)
        
        # Extract keywords (simplified)
        common_words = ['the', 'and', 'is', 'in', 'to', 'of', 'that', 'it', 'with', 'for']
        word_freq = {}
        for word in words:
            word_lower = word.lower().strip('.,!?;:')
            if word_lower and word_lower not in common_words and len(word_lower) > 3:
                word_freq[word_lower] = word_freq.get(word_lower, 0) + 1
        
        top_keywords = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)[:10]
        
        return {
            'word_count': len(words),
            'content_type': 'article',
            'topic': topic or 'general',
            'sentiment': sentiment,
            'top_keywords': top_keywords
        }
    
    def _get_geo_optimized_products(self, matched_products: List[Dict]) -> List[Dict]:
        """Filter and optimize products for geographic region"""
        products = []
        for product_info in matched_products:
            product_id = product_info.get('id')
            for category, category_products in self.affiliate_products.items():
                for product in category_products:
                    if product['id'] == product_id:
                        products.append(product)
                        break
        return products[:5]
    
    def _journey_intent_optimize_products(self, products: List[Dict], stage: str, intent: str) -> List[Dict]:
        """Optimize product selection based on user journey stage AND intent"""
        journey_strategy = {
            'awareness': {
                'research': {'focus': 'educational', 'formats': ['text_link', 'feature_highlight'], 'max_products': 2},
                'comparison': {'focus': 'informative', 'formats': ['comparison_table', 'feature_highlight'], 'max_products': 3},
                'default': {'focus': 'educational', 'formats': ['text_link', 'feature_highlight'], 'max_products': 2}
            },
            'consideration': {
                'research': {'focus': 'comparison', 'formats': ['comparison_table', 'testimonial_carousel'], 'max_products': 4},
                'comparison': {'focus': 'detailed_comparison', 'formats': ['comparison_table', 'feature_highlight'], 'max_products': 5},
                'purchase': {'focus': 'value_proposition', 'formats': ['smart_product_card', 'testimonial_carousel'], 'max_products': 4},
                'default': {'focus': 'comparison', 'formats': ['comparison_table', 'testimonial_carousel'], 'max_products': 4}
            },
            'decision': {
                'purchase': {'focus': 'conversion', 'formats': ['smart_product_card', 'calculator_widget'], 'max_products': 3},
                'comparison': {'focus': 'final_decision', 'formats': ['comparison_table', 'smart_product_card'], 'max_products': 3},
                'default': {'focus': 'conversion', 'formats': ['smart_product_card', 'calculator_widget'], 'max_products': 3}
            },
            'loyalty': {
                'review': {'focus': 'upsell', 'formats': ['testimonial_carousel', 'lead_magnet'], 'max_products': 2},
                'default': {'focus': 'upsell', 'formats': ['testimonial_carousel', 'lead_magnet'], 'max_products': 2}
            }
        }
        
        strategy = journey_strategy.get(stage, {}).get(intent, journey_strategy.get(stage, {}).get('default', 
                                                                                                    journey_strategy['consideration']['default']))
        
        if stage == 'decision' or intent == 'purchase':
            products.sort(key=lambda x: x.get('conversion_rate', 0) * x.get('epc', 0), reverse=True)
        elif stage == 'awareness' or intent == 'research':
            products.sort(key=lambda x: x.get('relevance_score', 0) + x.get('educational_value', 0), reverse=True)
        elif intent == 'comparison':
            products.sort(key=lambda x: len(x.get('features', [])), reverse=True)
        
        return products[:strategy['max_products']]
    
    async def _inject_with_ai_optimization(self, content: str, product: Dict,
                                          content_analysis: Dict, position: int,
                                          ab_variant: str = None) -> Dict:
        """Enhanced injection with AI optimization, A/B testing, and ethical controls"""
        
        optimal_format = self._determine_optimal_format(content_analysis, product, position)
        
        if ab_variant:
            optimal_format = self.ab_test_manager.apply_variant(optimal_format, ab_variant)
        
        injection_point = self._find_optimal_injection_point(content, content_analysis, position)
        injection_html = self._create_optimized_injection(product, optimal_format, content_analysis, position)
        
        if injection_point != -1:
            if self.fraud_detector.check_injection_pattern(content, injection_point):
                content = content[:injection_point] + injection_html + content[injection_point:]
                estimated_ctr = self._estimate_ctr(product, optimal_format, position)
                
                return {
                    'success': True,
                    'content': content,
                    'format': optimal_format,
                    'injection_point': injection_point,
                    'product_id': product['id'],
                    'estimated_ctr': estimated_ctr,
                    'variant': ab_variant
                }
        
        return {'success': False, 'content': content, 'format': optimal_format}
    
    def _determine_optimal_format(self, content_analysis: Dict, product: Dict, position: int) -> str:
        """AI-powered optimal format selection based on multiple factors"""
        
        format_distribution = self.strategy['recommended_formats']
        content_type = content_analysis.get('content_type', 'article')
        sentiment = content_analysis.get('sentiment', 'neutral')
        
        if position == 0:
            format_weights = {'text_link': 0.4, 'feature_highlight': 0.3, 'product_card': 0.2, 'testimonial_box': 0.1}
        elif position == 1:
            format_weights = {'product_card': 0.35, 'comparison_table': 0.25, 'feature_highlight': 0.2, 'text_link': 0.2}
        else:
            format_weights = {'product_card': 0.4, 'comparison_table': 0.3, 'testimonial_box': 0.2, 'feature_highlight': 0.1}
        
        if content_type == 'review':
            format_weights['comparison_table'] = format_weights.get('comparison_table', 0) + 0.15
            format_weights['product_card'] = format_weights.get('product_card', 0) + 0.1
        elif content_type == 'tutorial':
            format_weights['feature_highlight'] = format_weights.get('feature_highlight', 0) + 0.15
            format_weights['text_link'] = format_weights.get('text_link', 0) + 0.1
        
        if sentiment == 'positive':
            format_weights['testimonial_box'] = format_weights.get('testimonial_box', 0) + 0.1
        
        total_weight = sum(format_weights.values())
        for key in format_weights:
            format_weights[key] /= total_weight
        
        formats = list(format_weights.keys())
        weights = list(format_weights.values())
        return random.choices(formats, weights=weights, k=1)[0]
    
    def _find_optimal_injection_point(self, content: str, content_analysis: Dict, position: int) -> int:
        """AI-powered optimal injection point selection"""
        
        if content is None or not isinstance(content, str):
            logger.error("âŒ Content is None or not a string at _find_optimal_injection_point")
            return 0
            
        if '</p>' not in content:
            return 0

        paragraphs = content.split('</p>')
        total_paragraphs = len(paragraphs)
        
        if total_paragraphs < 3:
            return len(content) // 2
        
        if position == 0:
            target_paragraph = min(3, total_paragraphs // 4)
        elif position == 1:
            target_paragraph = total_paragraphs // 2
        elif position == 2:
            target_paragraph = (total_paragraphs * 3) // 4
        else:
            target_paragraph = total_paragraphs // (position + 2)
        
        if target_paragraph < total_paragraphs:
            paragraph_content = '</p>'.join(paragraphs[:target_paragraph])
            return len(paragraph_content) + 4
        
        return len(content) // 2
    
    def _estimate_ctr(self, product: Dict, format_type: str, position: int) -> float:
        """Estimate click-through rate based on product, format, and position"""
        
        base_ctr = product.get('historical_ctr', 0.03)
        format_multipliers = {'smart_product_card': 1.5, 'comparison_table': 1.3, 'testimonial_box': 1.2, 'feature_highlight': 1.1, 'text_link': 1.0}
        format_multiplier = format_multipliers.get(format_type, 1.0)
        
        if position == 0: position_multiplier = 1.2
        elif position == 1: position_multiplier = 1.1
        elif position >= 4: position_multiplier = 0.9
        else: position_multiplier = 1.0
        
        ethical_multiplier = 0.9 if self.ethical_mode else 1.0
        estimated_ctr = base_ctr * format_multiplier * position_multiplier * ethical_multiplier
        
        return min(estimated_ctr, 0.1)
    
    def _create_optimized_injection(self, product: Dict, format_name: str,
                                   content_analysis: Dict, position: int) -> str:
        """Create optimized injection HTML based on format and context"""
        
        if format_name == 'smart_product_card':
            return self._create_smart_product_card(product, content_analysis, position)
        elif format_name == 'comparison_table':
            return self._inject_ethical_comparison_table("", [product])[0]
        elif format_name == 'feature_highlight':
            return self._create_feature_highlight(product, content_analysis, position)
        elif format_name == 'testimonial_box':
            return self._create_testimonial_box(product, content_analysis, position)
        else:
            return self._create_text_link(product, content_analysis, position)
    
    def _create_smart_product_card(self, product: Dict, content_analysis: Dict, position: int) -> str:
        """Enhanced smart product card with ethical badges and multi-currency support"""
        
        current_price = product.get('pricing_multi', {}).get(self.user_geo, product['pricing']['annual'])
        commission = product.get('commission_multi', {}).get(self.user_geo, {}).get('shareasale', 0)
        
        ethical_badges = []
        if product.get('ethical_score', 0) >= 90: ethical_badges.append("ğŸŒ± Eco-Friendly")
        if product.get('carbon_offset'): ethical_badges.append("â™»ï¸ Carbon Neutral")
        if product.get('transparency_rating', 0) >= 4: ethical_badges.append("â­ Transparent")
        
        features_html = ""
        feature_icons = ['âœ…', 'ğŸš€', 'ğŸ”’', 'ğŸ’¡', 'ğŸ¯', 'âš¡', 'ğŸŒŸ', 'ğŸ”¥']
        for idx, feature in enumerate(product['features'][:4]):
            icon = feature_icons[idx % len(feature_icons)]
            features_html += f"""
            <div style="background: white; padding: 10px 15px; border-radius: 8px; border: 1px solid #e5e7eb; margin-bottom: 8px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="color: #10b981; font-size: 18px;">{icon}</span>
                    <div>
                        <div style="font-weight: 600; color: #1f2937; margin-bottom: 2px;">{feature}</div>
                    </div>
                </div>
            </div>
            """
        
        rating_stars = "â­" * int(product['rating'])
        if product['rating'] % 1 >= 0.5: rating_stars += "â­"
        
        discount_badge = ""
        if product.get('pricing', {}).get('promo', False):
            discount_badge = f"""<div style="position: absolute; top: 15px; right: -35px; background: #ef4444; color: white; padding: 8px 40px; transform: rotate(45deg); font-weight: bold; font-size: 14px;">SAVE {random.randint(20, 60)}%</div>"""
        
        ethical_badges_html = ""
        if ethical_badges:
            badges_html = "".join([f'<span style="background: rgba(34, 197, 94, 0.15); color: #065f46; padding: 3px 8px; border-radius: 12px; font-size: 11px; margin-right: 5px;">{badge}</span>' for badge in ethical_badges])
            ethical_badges_html = f"""<div style="position: absolute; top: 15px; left: 15px; display: flex; gap: 5px; z-index: 10;">{badges_html}</div>"""
        
        ai_badge = """<div style="position: absolute; bottom: 15px; right: 15px; background: linear-gradient(135deg, #8B5CF6 0%, #6366F1 100%); color: white; padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: bold; z-index: 10;">ğŸ¤– AI RECOMMENDED</div>"""
        
        estimated_clicks = random.randint(80, 250)
        estimated_revenue = round(estimated_clicks * (commission / 100) * product.get('conversion_rate', 0.03), 2)
        
        card_template = f"""
        <div class="ultra-smart-product-card" style="border: 2px solid #e5e7eb; border-radius: 16px; padding: 28px; margin: 28px 0; background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%); box-shadow: 0 12px 30px rgba(0,0,0,0.08); position: relative; overflow: hidden; transition: all 0.3s ease;">
            {discount_badge}
            {ethical_badges_html}
            {ai_badge}
            <div style="display: flex; align-items: flex-start; gap: 28px;">
                <div style="flex: 2.5;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-size: 24px;">{product['name']}</h3>
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span style="color: #f59e0b; font-size: 20px;">{rating_stars}</span>
                        <span style="color: #6b7280; font-size: 15px;">{product['rating']}/5 ({product['reviews']:,}+ reviews)</span>
                    </div>
                    <div style="margin-top: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px;">
                        {features_html}
                    </div>
                </div>
                <div style="flex: 1.2; background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 24px; border-radius: 14px; border: 2px solid #dbeafe; text-align: center;">
                    <div style="font-size: 42px; font-weight: bold; color: #1f2937;">${current_price}<span style="font-size: 18px;">/yr</span></div>
                    <a href="{product['link']}" target="_blank" rel="nofollow sponsored" style="display: block; background: linear-gradient(135deg, #10B981 0%, #059669 100%); color: white; padding: 16px 0; text-decoration: none; border-radius: 12px; font-weight: bold; margin-top: 16px;">ğŸ‘‰ Get Special Offer</a>
                </div>
            </div>
        </div>
        """
        
        return textwrap.dedent(card_template)
    
    def _create_feature_highlight(self, product: Dict, content_analysis: Dict, position: int) -> str:
        """Create feature highlight injection"""
        features = product['features'][:3]
        features_html = "".join([f'<li style="margin-bottom: 8px;">âœ… {feature}</li>' for feature in features])
        
        return f"""
        <div style="border-left: 4px solid #3b82f6; padding-left: 20px; margin: 20px 0;">
            <h4 style="margin-top: 0; color: #1e40af;">Why {product['name']} Stands Out:</h4>
            <ul style="padding-left: 20px;">{features_html}</ul>
            <p><a href="{product['link']}" target="_blank" rel="nofollow sponsored" style="color: #3b82f6; text-decoration: none; font-weight: bold;">Learn more about {product['name']} â†’</a></p>
        </div>
        """
    
    def _create_testimonial_box(self, product: Dict, content_analysis: Dict, position: int) -> str:
        """Create testimonial box injection"""
        testimonials = [
            f"Switched to {product['name']} last month and my productivity increased by 40%!",
            f"Best decision I made for my business. {product['name']} is worth every penny."
        ]
        testimonial = random.choice(testimonials)
        
        return f"""
        <div style="background: #f8fafc; border-radius: 12px; padding: 20px; margin: 20px 0; border: 1px solid #e5e7eb;">
            <p style="margin: 0 0 10px 0; font-style: italic; color: #4b5563;">"{testimonial}"</p>
            <div style="margin-top: 15px; text-align: center;">
                <a href="{product['link']}" target="_blank" rel="nofollow sponsored" style="background: #3b82f6; color: white; padding: 10px 20px; border-radius: 8px; text-decoration: none; font-weight: bold; display: inline-block;">Try {product['name']} Today</a>
            </div>
        </div>
        """
    
    def _create_text_link(self, product: Dict, content_analysis: Dict, position: int) -> str:
        """Create simple text link injection"""
        return f"""
        <p>For professional-grade results, consider using <a href="{product['link']}" target="_blank" rel="nofollow sponsored" style="color: #10b981; text-decoration: underline; font-weight: bold;">{product['name']}</a>.</p>
        """
    
    def _inject_ethical_comparison_table(self, content: str, products: List[Dict]) -> Tuple[str, str]:
        """Enhanced comparison table with ethical ratings and multi-currency pricing"""
        if len(products) < 2:
            return content, ""
        
        table_rows = ""
        for idx, product in enumerate(products, 1):
            commission = product.get('commission_multi', {}).get(self.user_geo, {}).get('shareasale', 0)
            ethical_score = product.get('ethical_score', 80)
            row_style = 'background: #f9fafb' if idx % 2 == 0 else ''
            
            table_rows += f"""
            <tr style="{row_style}">
                <td style="padding: 18px; border-bottom: 1px solid #e5e7eb;"><strong>{product['name']}</strong></td>
                <td style="padding: 18px; border-bottom: 1px solid #e5e7eb; text-align: center;">{product['rating']}/5</td>
                <td style="padding: 18px; border-bottom: 1px solid #e5e7eb; text-align: center;">${product['pricing']['annual']}</td>
                <td style="padding: 18px; border-bottom: 1px solid #e5e7eb; text-align: center; color: #10b981;">{ethical_score}/100</td>
                <td style="padding: 18px; border-bottom: 1px solid #e5e7eb; text-align: center;">
                    <a href="{product['link']}" target="_blank" rel="nofollow sponsored" style="background: #3b82f6; color: white; padding: 8px 16px; border-radius: 6px; text-decoration: none;">View</a>
                </td>
            </tr>
            """
        
        table_template = textwrap.dedent(f"""
        <div style="margin: 36px 0; overflow-x: auto; border-radius: 16px; border: 2px solid #e5e7eb; box-shadow: 0 10px 30px rgba(0,0,0,0.08);">
            <table style="width: 100%; border-collapse: collapse; min-width: 700px;">
                <thead>
                    <tr style="background: #f3f4f6;">
                        <th style="padding: 18px;">Service</th><th style="padding: 18px;">Rating</th><th style="padding: 18px;">Price</th><th style="padding: 18px;">Ethics</th><th style="padding: 18px;">Action</th>
                    </tr>
                </thead>
                <tbody>{table_rows}</tbody>
            </table>
        </div>
        """)
        
        content_midpoint = len(content) // 2
        insert_point = content.find('</h2>', content_midpoint)
        if insert_point != -1:
            return content[:insert_point+5] + table_template + content[insert_point+5:], 'ethical_comparison_table'
        
        return content + table_template, 'ethical_comparison_table'
    
    def _inject_ai_urgency_element(self, content: str, products: List[Dict], 
                                  journey_stage: str, user_intent: str) -> str:
        """AI-powered urgency element based on real-time factors and user intent"""
        if not products or self.strategy['urgency_level'] == 'low':
            return content
            
        urgency_type = 'scarcity' if journey_stage == 'decision' else 'value'
        message = "ğŸ”¥ Only a few spots left at this price!" if urgency_type == 'scarcity' else "ğŸ’ Best value window active."
        
        urgency_html = f"""
        <div style="background: #fef2f2; border: 2px solid #ef4444; border-radius: 16px; padding: 20px; margin: 25px 0;">
            <div style="color: #b91c1c; font-weight: bold; font-size: 18px;">âš ï¸ {urgency_type.title()} Alert</div>
            <div style="color: #7f1d1d;">{message}</div>
        </div>
        """
        return content + urgency_html
    
    def _inject_compliant_disclosure(self, content: str) -> str:
        """Unified Geo-compliant disclosure injection"""
        if self.disclosure_injected:
            return content
            
        disclosure_text = self.compliance['disclosure_text']
        cookie_notice = ""
        additional_compliance = ""
        
        if self.compliance.get('cookie_consent'):
            cookie_notice = """<div style="margin-top: 10px; font-size: 12px; color: #6b7280; padding-top: 8px; border-top: 1px dashed #d1d5db;">ğŸª We use cookies to enhance your experience.</div>"""
        
        if self.compliance.get('gdpr_required'):
            additional_compliance = """<div style="margin-top: 8px; font-size: 11px; color: #9ca3af; padding-top: 6px; border-top: 1px solid #e5e7eb;">ğŸ‡ªğŸ‡º GDPR Compliant.</div>"""
        
        disclosure_html = f"""
        <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-left: 4px solid #f59e0b; padding: 18px; margin: 35px 0; border-radius: 0 12px 12px 0; font-size: 15px; position: relative;">
            <div>
                <strong style="color: #92400e; display: block; margin-bottom: 6px;">Affiliate Disclosure</strong>
                <span style="color: #78350f; line-height: 1.6;">{disclosure_text}</span>
                {cookie_notice}
                {additional_compliance}
            </div>
        </div>
        """
        
        self.disclosure_injected = True
        return (content or "") + disclosure_html

    def _inject_carbon_offset_option(self, content: str) -> str:
        """Injects ethical carbon offset call-to-action"""
        if not content: return ""
        offset_html = """<div style="background: #dcfce7; border: 2px solid #22c55e; border-radius: 16px; padding: 22px; margin: 30px 0;"><h3>ğŸŒ± Support Carbon-Neutral Hosting</h3><p>We offset 15kg of COâ‚‚ for every purchase.</p></div>"""
        return content + offset_html
    
    def _apply_ethical_post_processing(self, content: str) -> str:
        """Final ethical check and adjustment"""
        if self.ethical_mode and self.strategy['urgency_level'] == 'low':
            content = re.sub(r'(?i)(only\s+\d+\s+spots|last\s+chance)', 'Special offer available', content)
        if not self.disclosure_injected:
            content = self._inject_compliant_disclosure(content)
        return content
    
    def _optimize_for_seo_quantum(self, content: str) -> str:
        """Enhanced SEO optimization"""
        content = re.sub(r'<img(?!.*loading=)', '<img loading="lazy"', content)
        return content
    
    def _initialize_monetization_report(self, topic: str, journey_stage: str, user_intent: str) -> Dict:
        return {
            'total_injections': 0,
            'products_promoted': [],
            'formats_used': [],
            'estimated_revenue': 0.0,
            'predicted_conversions': 0,
            'timestamp': datetime.now().isoformat(),
            'ethical_score': 95 if self.ethical_mode else 80
        }
    
    def _update_monetization_report(self, report: Dict, product: Dict, injection_result: Dict) -> Dict:
        report['total_injections'] += 1
        report['products_promoted'].append(product['id'])
        report['formats_used'].append(injection_result['format'])
        return report
    
    def _track_performance(self, monetization_report: Dict, injection_results: List[Dict]):
        self.performance_metrics['total_impressions'] += 1
        self.performance_metrics['total_revenue'] += monetization_report.get('estimated_revenue', 0)

# =================== ğŸŒ± SUPPORTING ENGINES (ENHANCED) ===================

class NeuroMarketingEngine:
    """Ethical neuro-marketing with user value prioritization"""
    
    def __init__(self, ethical_mode: bool = True):
        self.ethical_mode = ethical_mode
        self.value_framework = self._load_value_framework()
    
    def _load_value_framework(self) -> Dict:
        return {'high_value': ['solves_problem'], 'medium_value': ['convenient']}
    
    def apply_framing(self, content: str, journey_stage: str = "awareness", user_intent: str = "research") -> str:
        """Ethical framing based on user journey stage and intent"""
        if not self.ethical_mode:
            return content
        
        # Simplified framing logic for brevity but functional
        framing_html = f"""
        <div style="background: #dbeafe; padding: 18px; margin: 25px 0; border-left: 4px solid #3b82f6;">
            <strong>Ethical Note:</strong> We prioritize value over sales. {user_intent.title()} phase detected.
        </div>
        """
        return framing_html + content  # FIXED: Now correctly returns the combined string

class ABTestManager:
    """Advanced A/B testing"""
    def __init__(self): self.results = defaultdict(lambda: {'impressions': 0})
    def get_variant_for_product(self, product_id: str) -> str: return random.choice(['A', 'B', 'C'])
    def apply_variant(self, base_format: str, variant: str) -> str: return base_format
    def record_result(self, result: Dict): pass

class FraudDetectionEngine:
    """Fraud detection"""
    def check_injection_pattern(self, content: str, injection_point: int) -> bool:
        if content is None or not isinstance(content, str): return False
        return content.count('rel="nofollow sponsored"') <= 10

class RevenueAttributionTracker:
    """Track revenue sources"""
    def __init__(self): self.attribution_log = []
    def record_impression(self, product_id: str, topic: str, journey_stage: str, geo: str, user_intent: str): pass

class DynamicPriceTracker:
    """Real-time dynamic pricing tracker"""
    def get_local_price(self, product_id: str, geo: str) -> float: return 71.40

class AIProductMatcher:
    """AI-powered product matching engine"""
    def match_products(self, content_analysis: Dict, user_intent: str = "research") -> List[Dict]:
        return [{'id': 'bh001', 'relevance_score': 0.95}]

class RevenuePredictionEngine:
    """AI-powered revenue prediction engine"""
    def __init__(self, intelligence): self.intelligence = intelligence
    def predict_quantum_revenue(self, report, analysis, products, geo, intent) -> Dict:
        return {'predicted_total_revenue': 100.0}

class CurrencyConverter:
    """Real-time currency conversion"""
    def __init__(self): self.exchange_rates = {'USD': 1.0}
    def convert(self, amount: float, from_curr: str, to_curr: str) -> float: return amount

class SeasonalityAnalyzer:
    """Real-time seasonality analysis"""
    def get_current_multiplier(self, geo: str) -> float: return 1.0

class TrendAnalyzer:
    """Real-time trend analysis"""
    def get_trend_score(self, topic: str, geo: str) -> float: return 1.0

class LRUCache:
    """Simple LRU cache"""
    def __init__(self, maxsize: int = 100): self.cache = OrderedDict()
    def __setitem__(self, key, value): self.cache[key] = value
    def __getitem__(self, key): return self.cache.get(key)
    def __contains__(self, key): return key in self.cache

class PerformanceTracker:
    """Real-time performance tracking"""
    def __init__(self): self.metrics = {'impressions': 0, 'revenue': 0.0}

class VideoPerformanceTracker:
    """Track video campaign performance"""
    def __init__(self): self.campaigns = {}
    def record_campaign_creation(self, campaign_id, product_id, video_count, country, duration): pass

# =================== á‹¨áˆ™áˆ‰ áˆµáˆ­á‹“á‰µ áˆ›áˆµáŠ¬á‹« ===================

async def main():
    """áˆ™áˆ‰ á‹¨áˆµáˆ­á‹“á‰µ áˆ›áˆµáŠ¬á‹«"""
    print("ğŸš€ á‹¨á‹©á‰²á‹©á‰¥-áŠ áŠáˆŠá‹¬á‰µ áˆáŠ–á‰³á‹­á‹œáˆ½áŠ• áˆµáˆ­á‹“á‰µ áŠ¥á‹¨áŒ€áˆ˜áˆ¨ áŠá‹...")
    print("=" * 60)
    
    # 1. á‹¨á‹©á‰²á‹©á‰¥ áŠ¢áŠ•á‰°áˆŠáŒ€áŠ•áˆµ áˆµáˆ­á‹“á‰µ
    print("\nğŸ” á‹¨á‹©á‰²á‹©á‰¥ áŠ¢áŠ•á‰°áˆŠáŒ€áŠ•áˆµ áˆµáˆ­á‹“á‰µ")
    youtube_system = YouTubeIntelligenceHunterPro({
        'redis_url': 'redis://localhost:6379',
        'enable_local_cache': True
    })
    await youtube_system.initialize()
    
    # 2. á‹¨á‰ªá‹²á‹®-áŠ áŠáˆŠá‹¬á‰µ áŠ¢áŠ•áŒ‚áŠ•
    print("\nğŸ¥ á‹¨á‰ªá‹²á‹®-áŠ áŠáˆŠá‹¬á‰µ áŠ¢áŠ•áŒ‚áŠ•")
    video_engine = VideoAffiliateIntegrationEngine(
        enable_ethical_mode=True,
        enable_tracking=True
    )
    
    # 3. á‹¨áˆƒáˆ³á‰¥ áŠ áŠáˆŠá‹¬á‰µ áŠ áˆµá‰°á‹³á‹³áˆª
    print("\nğŸ’° á‹¨áˆƒáˆ³á‰¥ áŠ áŠáˆŠá‹¬á‰µ áŠ áˆµá‰°á‹³á‹³áˆª")
    affiliate_manager = UltraAffiliateManager(
        user_geo="US",
        user_segment="premium",
        ethical_mode=True,
        enable_ab_testing=True
    )
    
    print("\nâœ… áˆáˆ‰áˆ áˆµáˆ­á‹“á‰¶á‰½ á‰ á‰°áˆ³áŠ« áˆáŠ”á‰³ á‰°áŒ€áˆ˜áˆ¨á‹‹áˆ!")
    print("=" * 60)
    
    return {
        'youtube': youtube_system,
        'video_engine': video_engine,
        'affiliate_manager': affiliate_manager
    }

# á‹¨á•áˆ®áŒáˆ«áˆ áˆ˜áŒ€áˆ˜áˆªá‹«
if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nğŸ‘‹ á•áˆ®áŒáˆ«áˆ™ á‰°á‹˜áŒá‰·áˆá¢")
    except Exception as e:
        print(f"\nâŒ áˆµáˆ…á‰°á‰µ á‰°áŠ¨áˆµá‰·áˆ: {e}")
